---
layout: post
title: "Swift Notes"
date: 2015-01-01 00:00:00 +0000
comments: true
categories: iOS
tags: Swift
author: Alwyn Lombaard
published: true
excerpt_separator: <!--more-->
---

<!--more-->

## Swift Summary

##Swift
- Swift eliminates entire classes of unsafe code. Variables are always initialized before use, arrays and integers are checked for overflow, memory is automatically managed, and enforcement of exclusive access to memory guards against many programming mistakes
- Another safety feature is that by default Swift objects can never be nil
- Swift has an innovative feature known as optionals. An optional may contain nil, but Swift syntax forces you to safely deal with it using the ? syntax to indicate to the compiler you understand the behavior and will handle it safely.
- Swift is a successor to both the C and Objective-C languages. It includes low-level primitives such as types, flow control, and operators. It also provides object-oriented features such as classes, protocols, and generics, giving Cocoa and Cocoa Touch developers the performance and power they demand.

- Overview
    - Use let to make a constant and var to make a variable
    - String interlopation 
            
            let name = "John" 
            let greeting = "Hello \(name)"
    - Create arrays and dictionaries using brackets ([]), and access their elements by writing the index or key in brackets. A comma is allowed after the last element.
            
            var myList = ["item1", "item2", "item3"]

            var myDictionary = [
                "Key1": "Value1",
                "Key2": "Value2
            ]

            myDictionary["Key1"] = "Value x"

            myList.append("item4")

            let emptyArray = [String]()
            let emptyDictionary = [String: Float]()

    - type information can be inferred

            myList = []
            myDictionary = [:]

    - Control Flow
        - Use `if` and `switch` to make conditionals, and use `for`-`in`, `while`, and `repeat-while` to make loops. Parentheses around the condition or loop variable are optional. Braces around the body are required.

                let vegetable = "red pepper"
                switch vegetable {
                case "celery":
                    print("Add some raisins and make ants on a log.")
                case "cucumber", "watercress":
                    print("That would make a good tea sandwich.")
                case let x where x.hasSuffix("pepper"):
                    print("Is it a spicy \(x)?")
                default:
                    print("Everything tastes good in soup.")
                }
                // Prints "Is it a spicy red pepper?"

        - You can keep an index in a loop by using `..<` to make a range of indexes.

                var total = 0
                for i in 0..<4 {
                    total += i
                }
                print(total)
                // Prints "6"

        - Use `..<` to make a range that omits its upper value, and use `...` to make a range that includes both values.
    
    - Functions and Closures
        - Use `func` to declare a function. Call a function by following its name with a list of arguments in parentheses. Use `->` to separate the parameter names and types from the function’s return type.

                func greet(person: String, day: String) -> String {
                    return "Hello \(person), today is \(day)."
                }
                greet(person: "Bob", day: "Tuesday")
        - By default, functions use their parameter names as labels for their arguments. Write a custom argument label before the parameter name, or write `_` to use no argument label.

                func greet(_ person: String, on day: String) -> String {
                    return "Hello \(person), today is \(day)."
                }
                greet("John", on: "Wednesday")
        - Use a tuple to make a compound value—for example, to return multiple values from a function. The elements of a tuple can be referred to either by name or by number.

                func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
                    var min = scores[0]
                    var max = scores[0]
                    var sum = 0

                    for score in scores {
                        if score > max {
                            max = score
                        } else if score < min {
                            min = score
                        }
                        sum += score
                    }

                    return (min, max, sum)
                }
                let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
                print(statistics.sum)
                // Prints "120"
                print(statistics.2)
                // Prints "120"
        - Functions can be nested. Nested functions have access to variables that were declared in the outer function. You can use nested functions to organize the code in a function that is long or complex.

                func returnFifteen() -> Int {
                    var y = 10
                    func add() {
                        y += 5
                    }
                    add()
                    return y
                }
                returnFifteen()
        - Functions are a first-class type. This means that a function can return another function as its value.

                func makeIncrementer() -> ((Int) -> Int) {
                    func addOne(number: Int) -> Int {
                        return 1 + number
                    }
                    return addOne
                }
                var increment = makeIncrementer()
                increment(7)

        - A function can take another function as one of its arguments.

                func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
                    for item in list {
                        if condition(item) {
                            return true
                        }
                    }
                    return false
                }
                func lessThanTen(number: Int) -> Bool {
                    return number < 10
                }
                var numbers = [20, 19, 7, 12]
                hasAnyMatches(list: numbers, condition: lessThanTen)
        - You can write a closure without a name by surrounding code with braces (`{}`). Use `in` to separate the arguments and return type from the body.

                numbers.map({ (number: Int) -> Int in
                    let result = 3 * number
                    return result
                })
        - You have several options for writing closures more concisely. When a closure’s type is already known, such as the callback for a delegate, you can omit the type of its parameters, its return type, or both. Single statement closures implicitly return the value of their only statement.

                let mappedNumbers = numbers.map({ number in 3 * number })
                print(mappedNumbers)
                // Prints "[60, 57, 21, 36]"
        - You can refer to parameters by number instead of by name—this approach is especially useful in very short closures. A closure passed as the last argument to a function can appear immediately after the parentheses. When a closure is the only argument to a function, you can omit the parentheses entirely.

                let sortedNumbers = numbers.sorted { $0 > $1 }
                print(sortedNumbers)
                // Prints "[20, 19, 12, 7]"


### SwiftUI
- SwiftUI uses a declarative syntax so you can simply state what your user interface should do.


`text`

{% highlight csharp %}

public class SomeCSharpCode
{

}

{% endhighlight %}

{% highlight xml%}
<SomeXml>
</SomeXml>
{% endhighlight %}
