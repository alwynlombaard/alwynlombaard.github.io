---
layout: post
title: "Xamarin Summary"
date: 2015-01-01 00:00:00 +0000
comments: true
categories: Xamarin
tags: Xamarin
author: Alwyn Lombaard
published: true
excerpt_separator: <!--more-->
---

<!--more-->

## Xamarin.Forms Summary

### Xamarin.Forms Fundamentals
#### **Templates**
- **ControlTemplate**
    - Defines the visual structure of `ContentView` derived custom controls, and `ContentPage` derived pages. Control templates separate the user interface (UI) for a custom control, or page, from the logic that implements the control or page.
        - Create control template with single parent in Resource Dictionary. 
            - Set `BindingContext="{Binding Source={RelativeSource TemplatedParent}}"` on root view to bind to properties of custom control or  use `TemplateBinding` markup extension.
        - Set `ControlTemplate` attribute of custom control resource in XAML
        - A `ContentPresenter` can be placed in a control template to mark where content to be displayed
- **DataTemplate**
    - Defines the presentation of data on supported controls.
        - DataTemplate creation
            - A common usage scenario for a `DataTemplate` is displaying data from a collection of objects in a `CollectionView`. The appearance of the data for each cell in the `CollectionView` can be managed by setting the `CollectionView.ItemTemplate` property.

            - Data templates can be created inline, in a `ResourceDictionary`, or from a custom type. 
                - Creating Inline DataTemplate
                
                    ```
                    <CollectionView.ItemTemplate>
                        <DataTemplate>
                            <Grid>
                            ...  
                            </Grid>
                        </DataTemplate>
                    </CollectionView.ItemTemplate>
                    ```
                - Creating DataTemplate with a Type

                    ```
                    <CollectionView.ItemTemplate>
                        <DataTemplate>
                            <local:MyContentView />
                        </DataTemplate>
                    </CollectionView.ItemTemplate>
                    ```
                - Creating `DataTemplate` as a `Resource`

                    ```
                    <ContentPage.Resources>
                        <ResourceDictionary>
                            <DataTemplate x:Key="myTemplate">
                                    <Grid>
                                        ...
                                    </Grid>
                            </DataTemplate>
                        </ResourceDictionary>
                    </ContentPage.Resources>
                    ...
                    <CollectionView ItemTemplate="{StaticResource myTemplate}" />
                    ```

            
        - DataTemplate selection
            - A `DataTemplateSelector` can be used to choose a DataTemplate at runtime based on the value of a data-bound property.
                - A data template selector is implemented by creating a class that inherits from `DataTemplateSelector`. The `OnSelectTemplate` method is then overridden to return a particular DataTemplate 

                Example
                ```
                    public class MyDataTemplateSelector : DataTemplateSelector
                    {
                        public DataTemplate ValidTemplate { get; set; }
                        public DataTemplate InvalidTemplate { get; set; }

                        protected override DataTemplate OnSelectTemplate (object item, BindableObject container)
                        {
                            return ((MyItem)item).DateOfBirth.Year >= 1980 ? ValidTemplate : InvalidTemplate;
                        }
                    } 
                ```
                ```
                    <ResourceDictionary>
                        <DataTemplate x:Key="validItemTemplate">
                            <Grid>
                            ...
                            </Grid>
                        </DataTemplate>
                        <DataTemplate x:Key="invalidItemTemplate">
                            <Grid>
                            ...
                            </Grid>
                        </DataTemplate>
                        <local:MyDataTemplateSelector x:Key="myDataTemplateSelector"
                            ValidTemplate="{StaticResource validItemTemplate}"
                            InvalidTemplate="{StaticResource invalidItemTemplate}" />
                    </ResourceDictionary>  
                ```
                ```
                    <CollectionView 
                    ItemTemplate="{StaticResource myDataTemplateSelector}" />
                ```

                - Limitations
                    - The DataTemplateSelector subclass must always return the same template for the same data if queried multiple times.
                    - The DataTemplateSelector subclass must not return another DataTemplateSelector subclass.
                    - The DataTemplateSelector subclass must not return new instances of a DataTemplate on each call. Instead, the same instance must be returned. Failure to do so will create a memory leak and will disable virtualization.
                    - On Android, there can be no more than 20 different data templates per ListView.

#### **Triggers**
- Some Triggers (Except EventTrigger for example) can have a collecion of `EnterActions` and `ExitActions` that is `IList` of type `TriggerAction<T>`. EnterActions are executed when the trigger conditions are met and ExitActions are executed when the trigger conditions are no longer met.
    ```
    <Entry>
        <Entry.Triggers>
            <Trigger TargetType="Entry"
                    Property="IsFocused" Value="True">
                <Trigger.EnterActions>
                    <local:MyTriggerAction1 />
                </Trigger.EnterActions>

                <Trigger.ExitActions>
                    <local:MyTriggerAction2 />
                </Trigger.ExitActions>
            </Trigger>
        </Entry.Triggers>
    </Entry>
    ```


- **PropertyTrigger**
    ```
    <Entry>
        <Entry.Triggers>
            <Trigger TargetType="Entry"
                    Property="IsFocused" 
                    Value="True">
                <Setter Property="BackgroundColor" 
                    Value="Yellow" />
            </Trigger>
        </Entry.Triggers>
    </Entry>
    ```
- **DataTrigger**
    - Data triggers use data binding to monitor another control to cause the Setters to get called.


    ```
    <Button.Triggers>
        <DataTrigger TargetType="Button"
                    Binding="{Binding Source={x:Reference entry},
                                    Path=Text.Length}"
                    Value="0">
            <Setter Property="IsEnabled" Value="False" />
        </DataTrigger>
    </Button.Triggers>
    ```

- **EventTrigger**
    - Implement the generic `TriggerAction<T>` class where T is the type of the control such as Entry, or use base class such as `VisualElement` to target groups of controls. 
    - Override `Invoke` method.

    ```
    <EventTrigger Event="Clicked">
        <local:MyTriggerAction />
    </EventTrigger>
    ```
    ```
    public class MyTriggerAction : TriggerAction<Entry>
    {
        protected override void Invoke (Entry entry)
        {
            double result;
            bool isValid = Double.TryParse (entry.Text, out result);
            entry.TextColor = isValid ? Color.Default : Color.Red;
        }
    }
    ```

- **MultiTrigger**
    - Can have more than one condition. All the conditions must be true before the Setters are triggered.
    - Conditions include `BindingCondition` and `ProperyCondition`

    ```
    <MultiTrigger TargetType="Button">
        <MultiTrigger.Conditions>
            <BindingCondition 
                Binding="{Binding Source={x:Reference email},
                                    Path=Text.Length}"
                                Value="0" />
            <BindingCondition Binding="{Binding Source={x:Reference phone},
                                    Path=Text.Length}"
                                Value="0" />
        </MultiTrigger.Conditions>
        <Setter Property="IsEnabled" Value="False" />
    </MultiTrigger>
    ```
    ```
    <PropertyCondition Property="Text" Value="OK" />
    ```

- **State**
    - State triggers are a specialized group of triggers that define the conditions under which a `VisualState` should be applied.

        ```
        <Style TargetType="Grid">
            <Setter Property="VisualStateManager.VisualStateGroups">
                <VisualStateGroupList>
                    <VisualStateGroup>
                        <VisualState x:Name="Checked">
                            <VisualState.StateTriggers>
                                <!-- Add State Triggers here -->
                            <VisualState.Setters>
                                <Setter Property="BackgroundColor"
                                        Value="Black" />
                            </VisualState.Setters>
                        </VisualState>
                        <VisualState x:Name="Unchecked">
                            <VisualState.StateTriggers>
                                <!-- Add State Triggers here -->
                            </VisualState.StateTriggers>
                            <VisualState.Setters>
                                <Setter Property="BackgroundColor"
                                        Value="White" />
                            </VisualState.Setters>
                        </VisualState>
                    </VisualStateGroup>
                </VisualStateGroupList>
            </Setter>
        </Style>
        ```

        - **StateTrigger**
            - The `StateTrigger` class, which derives from the `StateTriggerBase` class, has an `IsActive` bindable property. A `StateTrigger` triggers a `VisualState` change when the `IsActive` property changes value.

            ```
            <StateTrigger IsActive="{Binding IsToggled}"
                IsActiveChanged="OnCheckedStateIsActiveChanged" />
            ```

        - **AdaptiveTrigger**
            - An `AdaptiveTrigger` triggers a VisualState change when the window is a specified height or width. This trigger has two bindable properties: `MinWindowHeight` and `MinWindowWidth`   

            ```
            <AdaptiveTrigger MinWindowWidth="0" />
            ```

        - **CompareStateTrigger**
            ```
            <CompareStateTrigger Property="{Binding Source={x:Reference checkBox}, 
              Path=IsChecked}"
                Value="True" />
            ```
        - **DeviceStateTrigger**
            ```
            <DeviceStateTrigger Device="iOS" />
            ```
            ```
            <DeviceStateTrigger Device="Android" />
            ```
        - **OrientationStateTrigger**
            ```
            <OrientationStateTrigger Orientation="Portrait" />
            ```

            ```
            <OrientationStateTrigger Orientation="Landscape" />
            ```

#### **Behaviors**
Adds functionality to a control without the need to subclass
- Attached Behaviors
    - Attached behaviors are static classes with one or more attached properties. 
    - An attached property is a special type of bindable property. They are defined in one class but attached to other objects, and they are recognizable in XAML as attributes that contain a class and a property name separated by a period.
    - Xamarin.Forms behaviors have replaced attached behaviors as the preferred approach to behavior construction.
- Xamarin.Forms Behaviors
    1. Create a class that inherits from the `Behavior` or `Behavior<T>` class, where T is the type of the control to which the behavior should apply.
    2. Override the `OnAttachedTo` method to perform any required setup.
    3. Override the `OnDetachingFrom` method to perform any required cleanup.
    4. Implement the core functionality of the behavior.

    ```
    <Entry>
        <Entry.Behaviors>
            <local:MyBehavior />
        </Entry.Behaviors>
    </Entry>
    ```

#### **Data Binding**
- Data binding is the technique of linking properties of two objects so that changes in one property are automatically reflected in the other property. Data binding is an integral part of the Model-View-ViewModel (MVVM) application architecture.
    - The target is the object (and property) on which the data binding is set.
    - The source is the object (and property) referenced by the data binding.
    - The target property must be backed by a bindable property.
    - The target object must be an instance of a class that derives from `BindableObject`

- Use `Binding` Markup Extension or `SetBinding()`

    ```
    Scale="{Binding Source={x:Reference slider}, Path=Value}" />
    ```

    ```
    Scale="{Binding Value, Source={x:Reference slider}}" />
    ```

- Other Markup Extensions
    - x:Static: Used when we want to access static properties, fields, or Enum members in XAML elements.
    - x:Reference: Used when we want to declare the reference of some named element into some other element of the same XAML Page.
    - x:Type: Used when we want to set the type of some attribute to System.Type object.
    - x:Array: Used when we want to construct the array of objects of some specific type.
    - x:Null: Used when we want to set the value of some attribute to a null.



- **Bindable Properties**

- **Binding Mode**
The binding mode is specified with a member of the BindingMode enumeration:

    - Default (OneWay)
    - TwoWay – data goes both ways between source and target
    - OneWay – data goes from source to target
    - OneWayToSource – data goes from target to source
    - OneTime – data goes from source to target, but only when the BindingContext changes 

- **String Formatting**

- **Binding Path**

- **Binding Value Converters**

- **Relative Bindings**

- **Binding Fallbacks**

- **Multi-Bindings**

- **Command Interface**

- **Compiled Bindings**

#### Effects
Simplifies customisation, is reusable and paramaterised. Is appropriate for property changes on platform specific control

Steps:
1. 1
2. 2
3. 3

#### Custom Renderers
Customise appearance and/or behavior. Required to override a method on a platform specific control or when there is a need to replace the platform specific control that implements a Xamarin.Forms control.

Steps:
1. 1
2. 2
3. 3

#### Gestures
- Tap
- Pinch
- Pan
- Swipe
- Drag & Drop

#### Navigation
- Hierarchical Navigation
    - The `NavigationPage` class provides a hierarchical navigation experience where the user is able to navigate through pages, forwards and backwards, as desired. The class implements navigation as a last-in, first-out (LIFO) stack of Page objects.
- TabbedPage
    - The Xamarin.Forms `TabbedPage` consists of a list of tabs and a larger detail area, with each tab loading content into the detail area.
- CarouselPage
    - The Xamarin.Forms `CarouselPage` is a page that users can swipe from side to side to navigate through pages of content, like a gallery.
- FlyoutPage
    - The Xamarin.Forms `FlyoutPage` is a page that manages two pages of related information – a flyout page that presents items, and a detail page that presents details about items on the flyout page.
- ModalPage
    - Xamarin.Forms also provides support for modal pages. A modal page encourages users to complete a self-contained task that cannot be navigated away from until the task is completed or cancelled.


#### Shell
- Xamarin.Forms Shell reduces the complexity of mobile application development by providing the fundamental features that most mobile applications require, including:
    - A single place to describe the visual hierarchy of an application.
    - A common navigation user experience.
    - A URI-based navigation scheme that permits navigation to any page in the application.
    - An integrated search handler. 
- Flyout
- Tabs
- Navigation



## SOLID
- Single-responsibility principle

    A class should only have a single responsibility, that is, only changes to one part of the software's specification should be able to affect the specification of the class.

- Open–closed principle

    "Software entities ... should be open for extension, but closed for modification."

- Liskov substitution principle

    "Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that program." 

- Interface segregation principle

    "Many client-specific interfaces are better than one general-purpose interface."

- Dependency inversion principle

    One should "depend upon abstractions, not concretions."

## OOD Paterns 
[ref](https://ronnieschaniel.medium.com/object-oriented-design-patterns-explained-using-practical-examples-84807445b092)
- **Creational**
    - Abstract Factory
        - The Abstract Factory provides an interface for creating families of related or dependent objects without the need to specify their concrete classes.
    - Factory Method
        - The Factory Method defines an interface for object creation but let’s the subclass decide which object to create.
    - Builder
        - The Builder pattern enables a more readable object creation and let’s you specify the fields that are actually needed.
    - Prototype
        - The prototype pattern helps if objects are expensive to create and new objects will be similar to existing objects. It uses the clone method to duplicate existing instances to be used as a prototype for new instances.
    - Singleton
        - A Singleton ensures that only one instance of an object is created and that this instance is globally accessible. There are not many occasions where it is acceptable to use a Singleton as it introduces global state. Logging is one meaningful example for the Singleton

- **Structural**
    - Adapter
        - The Adapter Pattern works between two independent or incompatible interfaces.
    - Bridge
        - The Bridge pattern is used to decouple interfaces from implementations, if there are hierarchies in interfaces as well as implementations. 
    - Composite
        - The composite pattern allows to treat a group of objects the same way as a single object. This is for example used in tree-like object structures where a parent node’s operation influences or is dependent on child nodes.
    - Decorator
        - The decorator pattern allows to add functionality to an object at run-time without altering its structure.
    - Facade
        - A Facade simplifies the interface to an object or a group of objects “behind” this facade.
    - Flyweight
        - The Flyweight pattern is applied if lots of objects from one class need to be constructed.
    - Proxy
        - In this pattern an object is a proxy to something else and can control the creation and access of it. 
- **Behavioural**
    - Chain of responsibility
       - This pattern creates a chain of receiver objects for a request. It avoids coupling the sender of a request to the receiver and gives multiple objects the chance to handle the request.
    - Command
        - In the command pattern an object is used to encapsulate all information needed to perform an action or trigger an event at a later time.
    - Interpreter
        - The Interpreter pattern defines a representation for the grammar of a language and provides the ability to interpret sentences of that language
    - Iterator
        - The Iterator is used to traverse a container of data to access the container’s elements without the need to know the underlying structure.
    - Mediator
        - If two or more objects need to cooperate, the Mediator pattern might be applied. Especially if the objects do not know each other, if they should not be tightly coupled, or their interaction is complex, this pattern can help.
    - Memento
        - The Memento pattern is useful if a certain state of an object should be saved for later usage.
    - Observer
        - In the observer pattern observer objects subscribe to an observable object to be notified every time the observable changes its data. Observers are loosely coupled and can be added and removed at run-time. With regard to how the observer finally gets the data from the observable, there are two variants: push and pull.
    - State
        - The State pattern lets an object alter its behaviour when its internal state changes. This pattern is similar to the strategy pattern, but in this case it is decided internally how the objects behaves.
    - Strategy
        - In the context of the Strategy pattern there exist multiple variants for one algorithm where one variant is chosen to be executed at runtime.
    - Template
        - The Template pattern defines a structure for sub classes in which steps of an algorithm and their order are defined. This ensures that the sub classes follow the exact same steps, providing better overview and consistency. It also allows to define default implementations for steps that can be overridden by subclasses.
    - Visitor
        - The Visitor pattern allows to apply one or more operation to a set of objects at run-time without having the operations tightly coupled with the object structure. This let’s you implement double dispatch where a function call to different concrete functions is depending on the run-time type of two objects.




`text`





{% highlight csharp %}

public class SomeCSharpCode
{

}

{% endhighlight %}

{% highlight xml%}
<SomeXml>
</SomeXml>
{% endhighlight %}
