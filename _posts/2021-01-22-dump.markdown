---
layout: post
title: "Xamarin Summary"
date: 2015-01-01 00:00:00 +0000
comments: true
categories: Xamarin
tags: Xamarin
author: Alwyn Lombaard
published: true
excerpt_separator: <!--more-->
---

<!--more-->

## Xamarin.Forms Summary

### Xamarin.Forms Fundamentals
#### **Templates**
- **ControlTemplate**
    - Defines the visual structure of `ContentView` derived custom controls, and `ContentPage` derived pages. Control templates separate the user interface (UI) for a custom control, or page, from the logic that implements the control or page.
        - Create control template with single parent in Resource Dictionary. 
            - Set `BindingContext="{Binding Source={RelativeSource TemplatedParent}}"` on root view to bind to properties of custom control or  use `TemplateBinding` markup extension.
        - Set `ControlTemplate` attribute of custom control resource in XAML
        - A `ContentPresenter` can be placed in a control template to mark where content to be displayed
- **DataTemplate**
    - Defines the presentation of data on supported controls.
        - DataTemplate creation
            - A common usage scenario for a `DataTemplate` is displaying data from a collection of objects in a `CollectionView`. The appearance of the data for each cell in the `CollectionView` can be managed by setting the `CollectionView.ItemTemplate` property.

            - Data templates can be created inline, in a `ResourceDictionary`, or from a custom type. 
                - Creating Inline DataTemplate
                
                    ```
                    <CollectionView.ItemTemplate>
                        <DataTemplate>
                            <Grid>
                            ...  
                            </Grid>
                        </DataTemplate>
                    </CollectionView.ItemTemplate>
                    ```
                - Creating DataTemplate with a Type

                    ```
                    <CollectionView.ItemTemplate>
                        <DataTemplate>
                            <local:MyContentView />
                        </DataTemplate>
                    </CollectionView.ItemTemplate>
                    ```
                - Creating `DataTemplate` as a `Resource`

                    ```
                    <ContentPage.Resources>
                        <ResourceDictionary>
                            <DataTemplate x:Key="myTemplate">
                                    <Grid>
                                        ...
                                    </Grid>
                            </DataTemplate>
                        </ResourceDictionary>
                    </ContentPage.Resources>
                    ...
                    <CollectionView ItemTemplate="{StaticResource myTemplate}" />
                    ```

            
        - DataTemplate selection
            - A `DataTemplateSelector` can be used to choose a DataTemplate at runtime based on the value of a data-bound property.
                - A data template selector is implemented by creating a class that inherits from `DataTemplateSelector`. The `OnSelectTemplate` method is then overridden to return a particular DataTemplate 

                Example
                ```
                    public class MyDataTemplateSelector : DataTemplateSelector
                    {
                        public DataTemplate ValidTemplate { get; set; }
                        public DataTemplate InvalidTemplate { get; set; }

                        protected override DataTemplate OnSelectTemplate (object item, BindableObject container)
                        {
                            return ((MyItem)item).DateOfBirth.Year >= 1980 ? ValidTemplate : InvalidTemplate;
                        }
                    } 
                ```
                ```
                    <ResourceDictionary>
                        <DataTemplate x:Key="validItemTemplate">
                            <Grid>
                            ...
                            </Grid>
                        </DataTemplate>
                        <DataTemplate x:Key="invalidItemTemplate">
                            <Grid>
                            ...
                            </Grid>
                        </DataTemplate>
                        <local:MyDataTemplateSelector x:Key="myDataTemplateSelector"
                            ValidTemplate="{StaticResource validItemTemplate}"
                            InvalidTemplate="{StaticResource invalidItemTemplate}" />
                    </ResourceDictionary>  
                ```
                ```
                    <CollectionView 
                    ItemTemplate="{StaticResource myDataTemplateSelector}" />
                ```

                - Limitations
                    - The DataTemplateSelector subclass must always return the same template for the same data if queried multiple times.
                    - The DataTemplateSelector subclass must not return another DataTemplateSelector subclass.
                    - The DataTemplateSelector subclass must not return new instances of a DataTemplate on each call. Instead, the same instance must be returned. Failure to do so will create a memory leak and will disable virtualization.
                    - On Android, there can be no more than 20 different data templates per ListView.

#### **Triggers**
- Some Triggers (Except EventTrigger for example) can have a collecion of `EnterActions` and `ExitActions` that is `IList` of type `TriggerAction<T>`. EnterActions are executed when the trigger conditions are met and ExitActions are executed when the trigger conditions are no longer met.
    ```
    <Entry>
        <Entry.Triggers>
            <Trigger TargetType="Entry"
                    Property="IsFocused" Value="True">
                <Trigger.EnterActions>
                    <local:MyTriggerAction1 />
                </Trigger.EnterActions>

                <Trigger.ExitActions>
                    <local:MyTriggerAction2 />
                </Trigger.ExitActions>
            </Trigger>
        </Entry.Triggers>
    </Entry>
    ```


- **PropertyTrigger**
    ```
    <Entry>
        <Entry.Triggers>
            <Trigger TargetType="Entry"
                    Property="IsFocused" 
                    Value="True">
                <Setter Property="BackgroundColor" 
                    Value="Yellow" />
            </Trigger>
        </Entry.Triggers>
    </Entry>
    ```
- **DataTrigger**
    - Data triggers use data binding to monitor another control to cause the Setters to get called.


    ```
    <Button.Triggers>
        <DataTrigger TargetType="Button"
                    Binding="{Binding Source={x:Reference entry},
                                    Path=Text.Length}"
                    Value="0">
            <Setter Property="IsEnabled" Value="False" />
        </DataTrigger>
    </Button.Triggers>
    ```

- **EventTrigger**
    - Implement the generic `TriggerAction<T>` class where T is the type of the control such as Entry, or use base class such as `VisualElement` to target groups of controls. 
    - Override `Invoke` method.

    ```
    <EventTrigger Event="Clicked">
        <local:MyTriggerAction />
    </EventTrigger>
    ```
    ```
    public class MyTriggerAction : TriggerAction<Entry>
    {
        protected override void Invoke (Entry entry)
        {
            double result;
            bool isValid = Double.TryParse (entry.Text, out result);
            entry.TextColor = isValid ? Color.Default : Color.Red;
        }
    }
    ```

- **MultiTrigger**
    - Can have more than one condition. All the conditions must be true before the Setters are triggered.
    - Conditions include `BindingCondition` and `ProperyCondition`

    ```
    <MultiTrigger TargetType="Button">
        <MultiTrigger.Conditions>
            <BindingCondition 
                Binding="{Binding Source={x:Reference email},
                                    Path=Text.Length}"
                                Value="0" />
            <BindingCondition Binding="{Binding Source={x:Reference phone},
                                    Path=Text.Length}"
                                Value="0" />
        </MultiTrigger.Conditions>
        <Setter Property="IsEnabled" Value="False" />
    </MultiTrigger>
    ```
    ```
    <PropertyCondition Property="Text" Value="OK" />
    ```

- **State**
    - State triggers are a specialized group of triggers that define the conditions under which a `VisualState` should be applied.

        ```
        <Style TargetType="Grid">
            <Setter Property="VisualStateManager.VisualStateGroups">
                <VisualStateGroupList>
                    <VisualStateGroup>
                        <VisualState x:Name="Checked">
                            <VisualState.StateTriggers>
                                <!-- Add State Triggers here -->
                            <VisualState.Setters>
                                <Setter Property="BackgroundColor"
                                        Value="Black" />
                            </VisualState.Setters>
                        </VisualState>
                        <VisualState x:Name="Unchecked">
                            <VisualState.StateTriggers>
                                <!-- Add State Triggers here -->
                            </VisualState.StateTriggers>
                            <VisualState.Setters>
                                <Setter Property="BackgroundColor"
                                        Value="White" />
                            </VisualState.Setters>
                        </VisualState>
                    </VisualStateGroup>
                </VisualStateGroupList>
            </Setter>
        </Style>
        ```

        - **StateTrigger**
            - The `StateTrigger` class, which derives from the `StateTriggerBase` class, has an `IsActive` bindable property. A `StateTrigger` triggers a `VisualState` change when the `IsActive` property changes value.

            ```
            <StateTrigger IsActive="{Binding IsToggled}"
                IsActiveChanged="OnCheckedStateIsActiveChanged" />
            ```

        - **AdaptiveTrigger**
            - An `AdaptiveTrigger` triggers a VisualState change when the window is a specified height or width. This trigger has two bindable properties: `MinWindowHeight` and `MinWindowWidth`   

            ```
            <AdaptiveTrigger MinWindowWidth="0" />
            ```

        - **CompareStateTrigger**
            ```
            <CompareStateTrigger Property="{Binding Source={x:Reference checkBox}, 
              Path=IsChecked}"
                Value="True" />
            ```
        - **DeviceStateTrigger**
            ```
            <DeviceStateTrigger Device="iOS" />
            ```
            ```
            <DeviceStateTrigger Device="Android" />
            ```
        - **OrientationStateTrigger**
            ```
            <OrientationStateTrigger Orientation="Portrait" />
            ```

            ```
            <OrientationStateTrigger Orientation="Landscape" />
            ```

#### **Behaviors**
Adds functionality to a control without the need to subclass
- Attached Behaviors
    - Attached behaviors are static classes with one or more attached properties. 
    - An attached property is a special type of bindable property. They are defined in one class but attached to other objects, and they are recognizable in XAML as attributes that contain a class and a property name separated by a period.
    - Xamarin.Forms behaviors have replaced attached behaviors as the preferred approach to behavior construction.
- Xamarin.Forms Behaviors
    1. Create a class that inherits from the `Behavior` or `Behavior<T>` class, where T is the type of the control to which the behavior should apply.
    2. Override the `OnAttachedTo` method to perform any required setup.
    3. Override the `OnDetachingFrom` method to perform any required cleanup.
    4. Implement the core functionality of the behavior.

    ```
    <Entry>
        <Entry.Behaviors>
            <local:MyBehavior />
        </Entry.Behaviors>
    </Entry>
    ```

#### **Data Binding**
- Data binding is the technique of linking properties of two objects so that changes in one property are automatically reflected in the other property. Data binding is an integral part of the Model-View-ViewModel (MVVM) application architecture.
    - The target is the object (and property) on which the data binding is set.
    - The source is the object (and property) referenced by the data binding.
    - The target property must be backed by a bindable property.
    - The target object must be an instance of a class that derives from `BindableObject`

- Use `Binding` Markup Extension or `SetBinding()`

    ```
    Scale="{Binding Source={x:Reference slider}, Path=Value}" />
    ```

    ```
    Scale="{Binding Value, Source={x:Reference slider}}" />
    ```

- Other Markup Extensions
    - x:Static: Used when we want to access static properties, fields, or Enum members in XAML elements.
    - x:Reference: Used when we want to declare the reference of some named element into some other element of the same XAML Page.
    - x:Type: Used when we want to set the type of some attribute to System.Type object.
    - x:Array: Used when we want to construct the array of objects of some specific type.
    - x:Null: Used when we want to set the value of some attribute to a null.



- **Bindable Properties**

- **Binding Mode**
The binding mode is specified with a member of the BindingMode enumeration:

    - Default (OneWay)
    - TwoWay – data goes both ways between source and target
    - OneWay – data goes from source to target
    - OneWayToSource – data goes from target to source
    - OneTime – data goes from source to target, but only when the BindingContext changes 

- **String Formatting**

- **Binding Path**

- **Binding Value Converters**

- **Relative Bindings**

- **Binding Fallbacks**

- **Multi-Bindings**

- **Command Interface**

- **Compiled Bindings**

#### Effects
Simplifies customisation, is reusable and paramaterised. Is appropriate for property changes on platform specific control

Steps:
1. 1
2. 2
3. 3

#### Custom Renderers
Customise appearance and/or behavior. Required to override a method on a platform specific control or when there is a need to replace the platform specific control that implements a Xamarin.Forms control.

Steps:
1. 1
2. 2
3. 3

#### Gestures
- Tap
- Pinch
- Pan
- Swipe
- Drag & Drop

#### Navigation
- TabbedPage
- CarouselPage
- FlyoutPage
- ModalPage


#### Shell
- Flyout
- Tabs
- Navigation


`text`





{% highlight csharp %}

public class SomeCSharpCode
{

}

{% endhighlight %}

{% highlight xml%}
<SomeXml>
</SomeXml>
{% endhighlight %}
